---------------------------------------------------------------
libgf - Library for Gaussian basis functions
---------------------------------------------------------------
gf.hpp - Class for:

	Gaussian Functions (CGFs)

	Class : GF

	Attributes:
	exps  : list of exponents of PGFs
	d     : contraction coefficients
	xyz   : coordinates (x, y, z)
	shell : angular momenta (l, m, n)
	N     : normalization constants
	-------------------------------------------------------
	Misc Functions:
	
	E : expansion coefficients for Hermite Gaussians
	P : center of two combined GFs (from GPT)

---------------------------------------------------------------
// ============================
// 1. P(...) — Gaussian Product Center
// ============================

// --- THEORY ---
// When you multiply two Gaussian functions:
//   phi_A(r) = exp(-alpha * |r - A|^2)
//   phi_B(r) = exp(-beta  * |r - B|^2)
//
// The product is another Gaussian centered at:
//   P = (alpha * A + beta * B) / (alpha + beta)
//
// This point 'P' is called the Gaussian product center.
// It's used in all integrals like overlap, kinetic, nuclear attraction, and ERIs.

// --- CODE ---
double P(double a, double b, double xa, double xb) {
    return (a * xa + b * xb) / (a + b);
}

// This is done for x, y, z separately to get full vector P.


// ============================
// 2. E(...) — Obara-Saika Hermite Gaussian Recursion
// ============================

// --- THEORY ---
// Computes Hermite Gaussian coefficient E_t^{ij}
// where:
//   i, j = angular momentum indices (0=s, 1=p, etc.)
//   t   = Hermite polynomial order
//   Q   = distance between Gaussian centers (like xA - xB)
//   a, b = Gaussian exponents
//
// Base case:
//   E(0, 0, 0, a, b, Q) = exp(- (a * b / (a + b)) * Q^2 )
//
// Recursive relation:
//   E(i, j, t) =
//     (1 / 2p) * [ E(i-1, j, t-1) + E(i, j-1, t-1) ]
//     + ((i-1) / 2p) * E(i-2, j, t-1)
//     + ((j-1) / 2p) * E(i, j-2, t-1)
//     + (Q / p) * E(i, j, t-1)
//
// p = a + b
// q = (a * b) / (a + b)

// --- CODE ---
double E(int i, int j, int t, double a, double b, double Q) {
    double p = a + b;
    double q = a * b / p;

    // Out of bounds t
    if (t < 0 || t > (i + j)) return 0.0;

    // Base case
    if (i == 0 && j == 0 && t == 0)
        return exp(-q * Q * Q);

    double val = 0.0;

    if (i > 0)
        val += (1.0 / (2 * p)) * E(i - 1, j, t - 1, a, b, Q);

    if (j > 0)
        val += (1.0 / (2 * p)) * E(i, j - 1, t - 1, a, b, Q);

    if (i > 0)
        val += ((i - 1.0) / (2 * p)) * E(i - 2, j, t - 1, a, b, Q);

    if (j > 0)
        val += ((j - 1.0) / (2 * p)) * E(i, j - 2, t - 1, a, b, Q);

    val += (Q / p) * E(i, j, t - 1, a, b, Q);

    return val;
}

// This recursion is used to compute:
// - overlap integrals
// - kinetic energy integrals
// - nuclear attraction integrals
// - two-electron integrals (via McMurchie-Davidson or Obara-Saika)
